load("~/GitHub/university-projects/Statistical Data Modelling Projects - MTHM506/Coursework 1 - Practical Modelling Excersises and Theoretical Problems/datasets.RData")

# Question 1
head(nlmodel)

library(tidyverse)
library(ggplot2)

# Ploting X against Y, like in the question sheet.
ggplot(nlmodel, aes(x = x, y = y)) +
       geom_point()


#1c. 

mylike <- function(params, y, x) {
  # Defining the Parameters
  theta1 <- params[1]
  theta2 <- params[2]
  sigma <- params[3]
  
  # Defining the Mean
  mu <- (theta1 * x) / (theta2 +x)
  
  n <- length(y)
  
  # I have manually multiplied the equation by a minus to make this the negative log-likelihood
  result <- -n/2 * log(sqrt(2 * pi)) - n/2 * log(sigma^2) -
    sum((y - mu)^2) / (2 * sigma^2)
  
  return(-result)
}


####
####


#1d. Find the maximum likelihood estimates of theta1, theta2 and sigma.
# Using the nlm() function

# Create some starting values
x <- nlmodel$x
y <- nlmodel$y


# for Theta 1, sinces it directly influences y, ill start it near the mean of y
mean(y) # 176.8193
theta1_init <- 150
# Ill choose 150 as initial value

# For Theta 2, as its in the denominator, and directly influences x, ill start it near the mean of x.
mean(x) # 0.5341349
theta2_init <- 0.5
# Ill choose 0.5 for initial value

# for Sigma, ill use the SD of y.
sd(y) #39.45
sigma_init <- 40
#Ill choose 40 for initial value.

# Combine into a vector
inits <- c(theta1_init, theta2_init, sigma_init)

result <- nlm(mylike, p = inits, hessian = T, x = x, y = y, iterlim = 10000, steptol = 1e-10)

# Reporting estimates
mle_params <- result$estimate
names(mle_params) <- c("theta1", "theta2", "sigma")
print(mle_params)


# Creating scatter plot

# First extracting MLEs
theta1_mle <- mle_params[1]
theta2_mle <- mle_params[2]

# Calculate the fitted mean
fitted_mu <- (theta1_mle * x)/(theta2_mle + x)

plot_data <- data.frame(x = x, y = y, fitted_mu = fitted_mu)

ggplot(plot_data, aes(x = y, y = x)) +
  geom_point(size = 2, colour = "black") +
  geom_line(aes(x = fitted_mu), colour = "red", linewidth = 1.1) +
  labs(x = "Y", y = "X", title = "Scatter Plot with Fitted Mean Relationship") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

####
####

# 1e) Reporting standard errors for theta1 and theta2, and then constructing 95% CIs

result$hessian # Using the Hessian matrix to manually obtain the observed
# information matrix and compute the standard error for the two parameters.

OIM <- solve(result$hessian) # Observed information matrix
OIM

# Extract standard errors
std_errors <- sqrt(diag(OIM))
names(std_errors) <- c("theta1", "theta2", "sigma")
print(std_errors)

# Constructing 95% CIs

# Extract SE for theta1 and theta2
theta1_se <- std_errors["theta1"]
theta2_se <- std_errors["theta2"]

# Compute 95% CIs
theta1_ci <- c(theta1_mle - 1.96 * theta1_se, theta1_mle + 1.96 * theta1_se)
theta2_ci <- c(theta2_mle - 1.96 * theta2_se, theta2_mle + 1.96 * theta2_se)

# Printing CIs
cat("95% CI for theta1: [", theta1_ci[1], ",", theta1_ci[2], "]\n")
cat("95% CI for theta2: [", theta2_ci[1], ",", theta2_ci[2], "]\n")


####
####


# 1f) 

# Compute the z-statistic
z_stat <- (theta2_mle - 0.08) / theta2_se

# Print the z-statistic
z_stat

# z-stat is negative so use pnorm() which computes P(Z < z).
2*(pnorm(z_stat, 0, 1))

#Print p-value
p_value

#####
#####

# 1g)  Use plug-in prediction to construct and plot 95% prediction intervals

# Compute 95% prediction intervals
lower_bound <- fitted_mu - 1.96 * mle_params["sigma"]
upper_bound <- fitted_mu + 1.96 * mle_params["sigma"]

# Create a data frame for plotting
plot_data <- data.frame(x = x, y = y, fitted_mu = fitted_mu, 
                        lower = lower_bound, upper = upper_bound)

# Plot the observed data, fitted mean, and prediction intervals
ggplot(plot_data, aes(x = x, y = y)) +
  geom_point(size = 2, colour = "black") +  # Observed data
  geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1.1) +  # Fitted mean
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, fill = "blue") +  # Prediction interval
  labs(x = "X", y = "Y", title = "Scatter Plot with 95% Prediction Intervals") +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )
