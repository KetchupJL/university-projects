plot(pressure)
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
head(nlmodel)
library(tidyverse)
library(ggplot2)
ggplot(nlmodel, aes(x = x, y = y)) +
geom_point()
```{r Initial plot, echo=true}
---
title: "MTHM506-Statistical Data Modelling - Individual Project"
knitr::opts_chunk$set(echo = TRUE)
load("~/GitHub/university-projects/Statistical Data Modelling Projects - MTHM506/Coursework 1 - Practical Modelling Excersises and Theoretical Problems/datasets.RData")
head(nlmodel)
library(tidyverse)
library(ggplot2)
library(rmarkdown)
ggplot(nlmodel, aes(x = x, y = y)) +
geom_point()
```{r nlmodel, include=FALSE}
head(nlmodel)
load("~/GitHub/university-projects/Statistical Data Modelling Projects - MTHM506/Coursework 1 - Practical Modelling Excersises and Theoretical Problems/datasets.RData")
library(tidyverse)
library(ggplot2)
library(rmarkdown)
head(nlmodel)
ggplot(nlmodel, aes(x = x, y = y)) +
geom_point()
View(nlmodel)
mylike <- function(params, y, x) {
# Extract parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Calculate mean (mu) for each observation
mu <- (theta1 * x) / (theta2 + x)
# Calculate negative log-likelihood
nll <- -sum(dnorm(y, mean = mu, sd = sigma, log = TRUE))
return(nll)
}
View(mylike)
# Question 1
head(nlmodel)
mylike() <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
mylike() <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
mylike() <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
mylike() <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
mylike() <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
0
=
mylike() <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
mylike() <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- 100
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
View(mylike)
# for Theta 1, sinces it directly influences y, ill start it near the mean of y
theta1_init <- mean(y)
x <- nlmodel$x
y <- nlmodel$y
# for Theta 1, sinces it directly influences y, ill start it near the mean of y
theta1_init <- mean(y)
theta1_init
# For Theta 2, as its in the denominator, and directly influences x, ill start it near the mean of x.
theta2_init <- mean(x)
theta2_init
# for Sigma, ill use the SD of y.
sigma_init <- sd(y)
sigma_init
# Combine into a vector
inits <- c(theta1_init, theta2_init, sigma_init)
result <- nlm(f = mylike, p = inits, y = y, x = x)
sigma_init <- 40
theta1_init <- 150
theta2_init <- 0.5
# Combine into a vector
inits <- c(theta1_init, theta2_init, sigma_init)
result <- nlm(f = mylike, p = inits, y = y, x = x)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
(1 / (2 * sigma^2)) * sum((y - mu)^2)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
(1 / (2 * sigma^2)) * sum((y - mu)^2)
n <- length(y)
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
(1 / (2 * sigma^2)) * sum((y - mu)^2)
return(result)
}
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
(1 / (2 * sigma^2)) * sum((y - mu)^2)
return(result)
}
result <- nlm(f = mylike, p = inits, y = y, x = x)
print(result$estimate)
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- exp(params[3]))
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
(1 / (2 * sigma^2)) * sum((y - mu)^2)
return(result)
}
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- exp(params[3])
# Ensuring Sigma is positive
if (sigma <= 0) {
return(Inf)  # Return infinity if sigma is invalid
}
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
(1 / (2 * sigma^2)) * sum((y - mu)^2)
return(result)
}
result <- nlm(f = mylike, p = inits, y = y, x = x)
print(result$estimate)
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- n * log(sqrt(2 * pi)) + n * log(sigma) +
(1 / (2 * sigma^2)) * sum((y - mu)^2)
return(result)
}
result <- nlm(f = mylike, p = inits, y = y, x = x)
print(result$estimate)
result <- nlm(mylike, p = inits, hessian = T, iterlim = 10000, steptol = 1e-10)
result <- nlm(mylike, p = inits, hessian = T, iterlim = 10000, steptol = 1e-10)
result <- nlm(mylike, p = inits, hessian = T, x = x, y = y, iterlim = 10000, steptol = 1e-10)
print(result$estimate)
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- -n/2 * log(sqrt(2 * pi)) - n/2 * log(sigma^2) -
sum((y - mu)^2) / (2 * sigma^2)
return(result)
}
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- -n/2 * log(sqrt(2 * pi)) - n/2 * log(sigma^2) -
sum((y - mu)^2) / (2 * sigma^2)
return(-result)
}
# for Theta 1, sinces it directly influences y, ill start it near the mean of y
max(y)
# for Theta 1, sinces it directly influences y, ill start it near the mean of y
mean(y)
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- -n/2 * log(sqrt(2 * pi)) - n/2 * log(sigma^2) -
sum((y - mu)^2) / (2 * sigma^2)
return(-result)
}
result <- nlm(mylike, p = inits, hessian = T, x = x, y = y, iterlim = 10000, steptol = 1e-10)
print(result$estimate)
mylike <- function(params, y, x) {
# Defining the Parameters
theta1 <- params[1]
theta2 <- params[2]
sigma <- params[3]
# Defining the Mean
mu <- (theta1 * x) / (theta2 +x)
n <- length(y)
# I have manually multiplied the equation by a minus to make this the negative log-likelihood
result <- -n/2 * log(sqrt(2 * pi)) - n/2 * log(sigma^2) -
sum((y - mu)^2) / (2 * sigma^2)
return(-result)
}
theta1_init <- 150
theta2_init <- 0.5
sigma_init <- 40
# Combine into a vector
inits <- c(theta1_init, theta2_init, sigma_init)
inits <- c(theta1_init, theta2_init, sigma_init)
result <- nlm(mylike, p = inits, hessian = T, x = x, y = y, iterlim = 10000, steptol = 1e-10)
print(result$estimate)
sigma_init <- 50
theta2_init <- 0.5
theta1_init <- 200
inits <- c(theta1_init, theta2_init, sigma_init)
result <- nlm(mylike, p = inits, hessian = T, x = x, y = y, iterlim = 10000, steptol = 1e-10)
print(result$estimate)
####
sigma_init <- 40
theta1_init <- 150
# Combine into a vector
inits <- c(theta1_init, theta2_init, sigma_init)
result <- nlm(mylike, p = inits, hessian = T, x = x, y = y, iterlim = 10000, steptol = 1e-10)
print(result$estimate)
result <- nlm(mylike, start_params, y = y, x = x)
result <- nlm(mylike, inits, y = y, x = x)
print(result$estimate)
# Theta 2 is in the denominator, and directly influences x. ill start it near the mean of x.
medium(x) # 0.5341349
# Theta 2 is in the denominator, and directly influences x. ill start it near the mean of x.
median(x) # 0.5341349
# Theta 2 is in the denominator, and directly influences x. A reasonable guess is mean of X
mean(x) # 0.5302
theta1_mle <- mle_params[1]
mle_params <- result$estimate
names(mle_params) <- c("theta1", "theta2", "sigma")
print(mle_params)
theta1_mle <- mle_params[1]
theta2_mle <- mle_params[2]
# Calculate the fitted mean
fitted_mu <- (theta1_mle * x)/theta2_mle + x)
# Calculate the fitted mean
fitted_mu <- (theta1_mle * x)/(theta2_mle + x)
+ geom_line(x, fitted_mu)
plot_data <- data.frame(x = x, y = y, fitted_mu = fitted_mu)
plot_data
ggplot(plot_data, aes(x = x, y = y))
+ geom_point(size = 3, colour = "blue")
ggplot(plot_data, aes(x = x, y = y)) +
geom_point(size = 3, colour = "blue") +
geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1) +
labs(x = "X", y = "Y", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
ggplot(plot_data, aes(x = x, y = y)) +
geom_point(size = 2, colour = "blue") +
geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1) +
labs(x = "X", y = "Y", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
ggplot(plot_data, aes(x = x, y = y)) +
geom_point(size = 2, colour = "black") +
geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1) +
labs(x = "X", y = "Y", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
ggplot(plot_data, aes(x = x, y = y)) +
geom_point(size = 2, colour = "black") +
geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1.5) +
labs(x = "X", y = "Y", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
ggplot(plot_data, aes(x = x, y = y)) +
geom_point(size = 2, colour = "black") +
geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1.2) +
labs(x = "X", y = "Y", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
ggplot(plot_data, aes(x = x, y = y)) +
geom_point(size = 2, colour = "black") +
geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1.1) +
labs(x = "X", y = "Y", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
ggplot(plot_data, aes(x = y, y = x)) +
geom_point(size = 2, colour = "black") +
geom_line(aes(y = fitted_mu), colour = "red", linewidth = 1.1) +
labs(x = "Y", y = "X", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
ggplot(plot_data, aes(x = y, y = x)) +
geom_point(size = 2, colour = "black") +
geom_line(aes(x = fitted_mu), colour = "red", linewidth = 1.1) +
labs(x = "Y", y = "X", title = "Scatter Plot with Fitted Mean Relationship") +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold"),
axis.title = element_text(size = 12),
axis.text = element_text(size = 10)
)
result$hessian
result <- nlm(mylike, p = inits, hessian = T, x = x, y = y, iterlim = 10000, steptol = 1e-10)
result$hessian
OIM <- solve(result$hessian) # Observed information matrix
OIM
OIM[1,2]
OIM[1:2]
OIM[1:2, 2:2]
OIM[1:2, 2:2]
# Extract standard errors
std_errors <- sqrt(diag(OIM))
names(std_errors) <- c("theta1", "theta2", "sigma")
print(std_errors)
theta1_se <- std_errors["theta1"]
theta2_se <- std_errors["theta2"]
# Compute 95% confidence intervals
theta1_ci <- c(theta1_mle - 1.96 * theta1_se, theta1_mle + 1.96 * theta1_se)
theta2_ci <- c(theta2_mle - 1.96 * theta2_se, theta2_mle + 1.96 * theta2_se)
# Print confidence intervals
cat("95% CI for theta1: [", theta1_ci[1], ",", theta1_ci[2], "]\n")
cat("95% CI for theta2: [", theta2_ci[1], ",", theta2_ci[2], "]\n")
z_stat <- (theta2_mle - 0.08) / theta2_se
# Compute the p-value for the two-tailed test
z_p_value <- 2 * (1 - pnorm(z_stat, 0, 1))
# Results
z_stat
z_p_value
